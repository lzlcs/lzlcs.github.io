<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="lzl" />
  <meta name="description" content="" />
  
  
  <title>
    
      Pintos Project 2 
      
      
      |
    
     lzl&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">lzl</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Pintos Project 2</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-09-29 15:40:00
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Labs/" title="Labs">
                    <b>#</b> Labs
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Lab/" title="Lab">
                    #Lab
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/C/" title="C">
                    #C
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/OS/" title="OS">
                    #OS
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p><a target="_blank" rel="noopener" href="https://github.com/lzlcs/Courses"><code>Github</code></a><br>
Project 2 请在 <code>Linux</code> 环境下测试, 因为 <code>Windows</code> 下换行是 <code>\r\n</code>, <code>Linux</code> 环境下是 <code>\n</code></p>
<h1>预先准备</h1>
<p>先定义好一些变量并做好初始化, 之后会讲这些变量的意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">filesys_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_shadow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">tid_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">from</span>;</span>              <span class="comment">// 记录自己本体</span></span><br><span class="line">    <span class="type">int</span> exit_code;                    <span class="comment">// 本体结束的时候给出的退出码</span></span><br><span class="line">    <span class="type">bool</span> is_alive, is_being_waited;   <span class="comment">// 本体是否活着, 本体是否正在被等待</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">child_elem</span>;</span>      <span class="comment">// 配合 child_list</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> fd;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Owned by userprog/process.c. */</span></span><br><span class="line">    <span class="type">uint32_t</span> *pagedir;                  <span class="comment">/**&lt; Page directory. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">parent</span>;</span>   <span class="comment">// 记录父进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">child_list</span>;</span>  <span class="comment">// 记录子进程的影子</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_shadow</span> *<span class="title">to</span>;</span>       <span class="comment">// 记录自己的影子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_create</span>;</span> <span class="comment">// 用于创建的信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_wait</span>;</span>   <span class="comment">// 用于等待的信号量</span></span><br><span class="line">    <span class="type">bool</span> create_success;</span><br><span class="line">    <span class="type">int</span> exit_code;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_init</span> <span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  lock_init(&amp;filesys_lock);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">tid_t</span></span><br><span class="line"><span class="title function_">thread_create</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority,</span></span><br><span class="line"><span class="params">               thread_func *function, <span class="type">void</span> *aux)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* Initialize thread. */</span></span><br><span class="line">  init_thread (t, name, priority);</span><br><span class="line">  tid = t-&gt;tid = allocate_tid ();</span><br><span class="line">  t-&gt;parent = thread_current();</span><br><span class="line">  </span><br><span class="line">  t-&gt;to = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_shadow));</span><br><span class="line">  t-&gt;to-&gt;from = t;</span><br><span class="line">  t-&gt;to-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">  t-&gt;to-&gt;tid = tid;</span><br><span class="line">  t-&gt;to-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  t-&gt;to-&gt;is_being_waited = <span class="literal">false</span>;</span><br><span class="line">  list_push_back(&amp;t-&gt;parent-&gt;child_list, &amp;t-&gt;to-&gt;child_elem);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_thread</span> <span class="params">(<span class="keyword">struct</span> thread *t, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  t-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">  list_init(&amp;t-&gt;child_list);  </span><br><span class="line">  sema_init(&amp;t-&gt;sema_create, <span class="number">0</span>);</span><br><span class="line">  sema_init(&amp;t-&gt;sema_wait, <span class="number">0</span>);</span><br><span class="line">  t-&gt;create_success = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  list_init(&amp;t-&gt;file_list);</span><br><span class="line">  t-&gt;next_fd = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Part I: 参数分离</h1>
<ol>
<li>阅读文档中 <code>Program Startup Details</code> 了解如何把命令行参数压栈</li>
<li>阅读 <code>string.c</code>, <code>process.h</code> 了解函数功能
<ul>
<li><code>strtok_r</code>: 第一次调用时, <code>s</code> 是要分离参数的字符串, 之后调用时 <code>s</code> 位置必须为空<br>
每次返回值是字符串的下一个参数指针, 如果没有下一个参数, 返回 <code>NULL</code></li>
</ul>
</li>
<li>阅读 <code>process.c</code>, <code>process.h</code> 了解函数功能
<ul>
<li><code>process_executeute</code> 创建进程, 创建进程中的唯一线程, 线程执行 <code>start_process</code> 函数</li>
<li><code>start_process</code> 设置中断, 调用 <code>load</code> 函数创建用户地址空间</li>
<li><code>load</code> 函数执行完成之后, 调用 <code>setup_stack</code> 创建用户栈</li>
</ul>
</li>
</ol>
<p><code>start_process</code> 函数中 <code>load</code> 函数返回后, 说明地址空间和栈都已经创建好, 此时要把各种参数压栈</p>
<ol>
<li>修改 <code>process_executeute</code> 函数, 正确获取变量名</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tid_t</span></span><br><span class="line"><span class="title function_">process_execute</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *fn_copy, *get_name;</span><br><span class="line">  <span class="type">tid_t</span> tid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把文件拷贝两次, 这样就不会访问到 原来 file_name 的内容从而越界</span></span><br><span class="line">  fn_copy = palloc_get_page(<span class="number">0</span>);</span><br><span class="line">  get_name = palloc_get_page(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (fn_copy == <span class="literal">NULL</span> || get_name == <span class="literal">NULL</span>) <span class="keyword">return</span> TID_ERROR;</span><br><span class="line"></span><br><span class="line">  strlcpy (fn_copy, file_name, PGSIZE);</span><br><span class="line">  strlcpy (get_name, file_name, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取进程名字</span></span><br><span class="line">  <span class="type">char</span> *save_ptr;</span><br><span class="line">  get_name = strtok_r(get_name, <span class="string">&quot; &quot;</span>, &amp;save_ptr);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create a new thread to executeute FILE_NAME. */</span></span><br><span class="line">  tid = thread_create (get_name, PRI_DEFAULT, start_process, fn_copy);</span><br><span class="line">  <span class="comment">// 释放没用的 get_name 内存</span></span><br><span class="line">  palloc_free_page(get_name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tid == TID_ERROR)</span><br><span class="line">    palloc_free_page (fn_copy); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改 <code>start_process</code> 函数, 获取正确文件名, 分离参数并压栈</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start_process</span> <span class="params">(<span class="type">void</span> *file_name_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *file_name = file_name_;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">intr_frame</span> <span class="title">if_</span>;</span></span><br><span class="line">  <span class="type">bool</span> success;</span><br><span class="line">  <span class="comment">/* Initialize interrupt frame and load executeutable. */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;if_, <span class="number">0</span>, <span class="keyword">sizeof</span> if_);</span><br><span class="line">  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;</span><br><span class="line">  if_.cs = SEL_UCSEG;</span><br><span class="line">  if_.eflags = FLAG_IF | FLAG_MBS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new</span></span><br><span class="line">  <span class="comment">// 创建备份页面</span></span><br><span class="line">  <span class="type">char</span> *cmd = palloc_get_page(<span class="number">0</span>);</span><br><span class="line">  strlcpy(cmd, file_name_, PGSIZE);</span><br><span class="line">  <span class="comment">// 提取文件名</span></span><br><span class="line">  <span class="type">char</span> *save_ptr, *token;</span><br><span class="line">  file_name = strtok_r(file_name, <span class="string">&quot; &quot;</span>, &amp;save_ptr);</span><br><span class="line"></span><br><span class="line">  success = load (file_name, &amp;if_.eip, &amp;if_.esp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!success)</span><br><span class="line">  &#123;</span><br><span class="line">    palloc_free_page(cmd);</span><br><span class="line">    palloc_free_page(file_name);</span><br><span class="line">    thread_exit ();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把参数信息放到栈中</span></span><br><span class="line">  push_argument(&amp;if_.esp, cmd);</span><br><span class="line">  <span class="comment">// hex_dump((uintptr_t)if_.esp, if_.esp, (PHYS_BASE) - if_.esp, true); </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时 cmd 已经解析完了, 之后不会再用到, 所以释放</span></span><br><span class="line">  palloc_free_page(file_name);</span><br><span class="line">  palloc_free_page(cmd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// end new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;movl %0, %%esp; jmp intr_exit&quot;</span> : : <span class="string">&quot;g&quot;</span> (&amp;if_) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  NOT_REACHED ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>实现压栈的函数, 根据官方文档一步一步设置栈</li>
</ol>
<p><img src="https://github.com/lzlcs/image-hosting/raw/master/image.1hxbzkrp6af4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push_argument</span><span class="params">(<span class="type">void</span> **esp, <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// (*esp) 等价于 if_.esp</span></span><br><span class="line">  <span class="comment">// (*(int *)(*esp)) 表示栈中存的真实值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数数量和参数列表地址</span></span><br><span class="line">  <span class="type">int</span> argc = <span class="number">0</span>, argv[<span class="number">64</span>];</span><br><span class="line">  <span class="type">char</span> *token, *save_ptr; </span><br><span class="line"></span><br><span class="line">  (*esp) = PHYS_BASE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (token = strtok_r(cmd, <span class="string">&quot; &quot;</span>, &amp;save_ptr); token != <span class="literal">NULL</span>;</span><br><span class="line">       token = strtok_r(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;save_ptr))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(token);</span><br><span class="line">    (*esp) -= (len + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((*esp), token, len + <span class="number">1</span>);</span><br><span class="line">    argv[argc++] = (*esp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (*esp) = (<span class="type">int</span>)(*esp) &amp; <span class="number">0xfffffffc</span>;  <span class="comment">// word_align</span></span><br><span class="line">  (*esp) -= <span class="number">4</span>, (*(<span class="type">int</span> *)(*esp)) = <span class="number">0</span>;  <span class="comment">// argv[argc]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = argc - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// argv[i];</span></span><br><span class="line">    (*esp) -= <span class="number">4</span>, (*(<span class="type">int</span> *)(*esp)) = argv[i];</span><br><span class="line"></span><br><span class="line">  (*esp) -= <span class="number">4</span>, (*(<span class="type">int</span>*)(*esp)) = (*esp) + <span class="number">4</span>; <span class="comment">// argv</span></span><br><span class="line">  (*esp) -= <span class="number">4</span>, (*(<span class="type">int</span>*)(*esp)) = argc;       <span class="comment">// argc</span></span><br><span class="line">  (*esp) -= <span class="number">4</span>, (*(<span class="type">int</span>*)(*esp)) = <span class="number">0</span>;          <span class="comment">// return address</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时参数传递的部分完成, 但是因为还没有实现进程的父子结构以及写的系统调用 <br>
虽然此时 <code>make check</code> 一定会失败, 但是可以通过 <code>start_process</code> 设置栈之后调用 <code>hex_dump</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/pintos/src/userprog/build</span><br><span class="line">make &amp;&amp; pintos --filesys-size=2 -p tests/userprog/args-multiple -a args-multiple -- -f extract run &#x27;args-multiple some arguments for you!&#x27;</span><br></pre></td></tr></table></figure>
<p>结果如下即为正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bfffffb0              00 00 00 00-05 00 00 00 c0 ff ff bf |    ............|</span><br><span class="line">bfffffc0  f2 ff ff bf ed ff ff bf-e3 ff ff bf df ff ff bf |................|</span><br><span class="line">bfffffd0  da ff ff bf 00 00 00 00-00 00 79 6f 75 21 00 66 |..........you!.f|</span><br><span class="line">bfffffe0  6f 72 00 61 72 67 75 6d-65 6e 74 73 00 73 6f 6d |or.arguments.som|</span><br><span class="line">bffffff0  65 00 61 72 67 73 2d 6d-75 6c 74 69 70 6c 65 00 |e.args-multiple.|</span><br></pre></td></tr></table></figure>
<h1>Part II: 系统调用</h1>
<p><strong>准备工作</strong></p>
<p>首先通过阅读 <code>syscall.c</code> 上方的 <code>&lt;syscall-nr.h&gt;</code> 中得知 <br>
每个系统调用有自己的编号, 在 <code>Project2</code> 中只需要实现 <code>0 ~ 12</code> 这 13 个系统调用</p>
<p>通过阅读文档可知, 系统调用的编号在栈顶 <code>esp</code> 位置 <br>
通过 <code>pintos/src/lib/user/syscall.c</code> 的内容可知, 使用系统调用的方式是通过 <code>syscall</code> 的宏,<br>
四个宏实现不同参数数量的系统调用, 参数位置分别是 <code>esp + 4</code>, <code>esp + 8</code>, <code>esp + 12</code></p>
<p>阅读 <code>syscall.c</code> 中定义的函数</p>
<ol>
<li><code>syscall_init</code> 把系统调用注册为中断</li>
<li><code>syscall_handler</code> 进行系统调用的中断处理, 也就是选择对应的系统调用</li>
</ol>
<p><strong>具体实现</strong></p>
<ol start="0">
<li>在 <code>thread</code> 中定义错误码 <code>exit_code</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> exit_code;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>完善 <code>syscall_handler</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">syscall_handler</span> <span class="params">(<span class="keyword">struct</span> intr_frame *f UNUSED)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> number = *(<span class="type">int</span> *)(f-&gt;esp);</span><br><span class="line">  (func[number])(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>syscall_init</code> 中进行系统调用的注册</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_halt</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_exit</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_exec</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_wait</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_create</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_remove</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_open</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_filesize</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_read</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_write</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_seek</span><span class="params">(<span class="keyword">struct</span> intr_frame * f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_close</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func[<span class="number">20</span>])(<span class="keyword">struct</span> intr_frame *);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall_init</span> <span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  intr_register_int (<span class="number">0x30</span>, <span class="number">3</span>, INTR_ON, syscall_handler, <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line"></span><br><span class="line">  func[SYS_HALT] = syscall_halt;</span><br><span class="line">  func[SYS_EXIT] = syscall_exit;</span><br><span class="line">  func[SYS_EXEC] = syscall_exec;</span><br><span class="line">  func[SYS_WAIT] = syscall_wait;</span><br><span class="line">  func[SYS_CREATE] = syscall_create;</span><br><span class="line">  func[SYS_REMOVE] = syscall_remove;</span><br><span class="line">  func[SYS_OPEN] = syscall_open;</span><br><span class="line">  func[SYS_FILESIZE] = syscall_filesize;</span><br><span class="line">  func[SYS_READ] = syscall_read;</span><br><span class="line">  func[SYS_WRITE] = syscall_write;</span><br><span class="line">  func[SYS_SEEK] = syscall_seek;</span><br><span class="line">  func[SYS_TELL] = syscall_tell;</span><br><span class="line">  func[SYS_CLOSE] = syscall_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来根据文档一个个实现函数</p>
<ol>
<li><code>syscall_halt</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_halt</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  shutdown_power_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>syscall_exit</code> 错误码为第一个参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_exit</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> exit_code = *(<span class="type">int</span> *)(f-&gt;esp + <span class="number">4</span>);</span><br><span class="line">  thread_current()-&gt;exit_code = exit_code;</span><br><span class="line">  thread_exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>syscall_wait</code> 和 <code>syscall_execute</code>: 实现父子进程
<ul>
<li>可以通过信号量实现等待机制</li>
<li>考虑进程结束之后, 还需要留下信息给父进程访问, 新定义一个 <code>thread_shadow</code> <br>
影子需要记录本体的 <code>tid</code>, 以及是否在运行, 是否已经被等待过一次了</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threads/synch.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_shadow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">tid_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">from</span>;</span>              <span class="comment">// 记录自己本体</span></span><br><span class="line">    <span class="type">int</span> exit_code;                    <span class="comment">// 本体结束的时候给出的退出码</span></span><br><span class="line">    <span class="type">bool</span> is_alive, is_being_waited;   <span class="comment">// 本体是否活着, 本体是否正在被等待</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">child_elem</span>;</span>      <span class="comment">// 配合 child_list</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">parent</span>;</span>   <span class="comment">// 记录父进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">child_list</span>;</span>  <span class="comment">// 记录子进程的影子</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_shadow</span> *<span class="title">to</span>;</span>       <span class="comment">// 记录自己的影子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_wait</span>;</span>   <span class="comment">// 用于等待的信号量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在操作系统其他代码中, 直接调用的都是 <code>process_wait</code>, <code>process_exit</code>, <code>process_execute</code> 函数</p>
<ul>
<li><code>process_wait</code> 按照文档实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">process_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current ();</span><br><span class="line">  <span class="type">uint32_t</span> *pd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新子节点信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list</span>* <span class="title">l</span> =</span> &amp;cur-&gt;child_list;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">e</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin(l); e != list_end(l); e = list_next(e))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_shadow</span> *<span class="title">tmp</span> =</span> list_entry(e, <span class="keyword">struct</span> thread_shadow, child_elem);</span><br><span class="line">    <span class="comment">// 加此判断, tmp-&gt;from 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;is_alive)</span><br><span class="line">      tmp-&gt;from-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur-&gt;parent == <span class="literal">NULL</span>) <span class="built_in">free</span>(cur-&gt;to);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 把信息下放到影子</span></span><br><span class="line">    cur-&gt;to-&gt;exit_code = cur-&gt;exit_code;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;to-&gt;is_being_waited)</span><br><span class="line">      sema_up(&amp;cur-&gt;sema_wait);</span><br><span class="line"></span><br><span class="line">    cur-&gt;to-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line">    cur-&gt;to-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pd = cur-&gt;pagedir;</span><br><span class="line">  <span class="keyword">if</span> (pd != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      cur-&gt;pagedir = <span class="literal">NULL</span>;</span><br><span class="line">      pagedir_activate (<span class="literal">NULL</span>);</span><br><span class="line">      pagedir_destroy (pd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记得在尾部加上 退出信息</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: exit(%d)\n&quot;</span>, cur-&gt;name, cur-&gt;to-&gt;exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>process_execute</code> 需要保证子进程创建完成之后才返回, 从而获得子进程是否创建成功的状态 <br>
在 <code>thread</code> 中加入一个信号量, 在 <code>process_execute</code> 中 <code>P</code> 操作, 在 <code>start_process</code> 创建完成之后 <code>V</code> 操作,<br>
还需要保存一个子进程是否创建成功的布尔变量 <br>
注意 <code>sema_wait</code> 是等待进程结束, <code>sema_create</code> 是等待进程创建结束</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_create</span>;</span></span><br><span class="line">    <span class="type">bool</span> create_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process.c</span></span><br><span class="line"><span class="type">tid_t</span></span><br><span class="line"><span class="title function_">process_execute</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  sema_down(&amp;cur-&gt;sema_create);</span><br><span class="line">  <span class="keyword">if</span> (!cur-&gt;create_success) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start_process</span> <span class="params">(<span class="type">void</span> *file_name_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="keyword">if</span> (!success)</span><br><span class="line">  &#123;</span><br><span class="line">    palloc_free_page(cmd);</span><br><span class="line"></span><br><span class="line">    cur-&gt;exit_code = <span class="number">-1</span>;</span><br><span class="line">    cur-&gt;parent-&gt;create_success = <span class="literal">false</span>;   </span><br><span class="line">    sema_up(&amp;cur-&gt;parent-&gt;sema_create);</span><br><span class="line">    thread_exit ();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把参数信息放到栈中</span></span><br><span class="line">  push_argument(&amp;if_.esp, cmd);</span><br><span class="line">  <span class="comment">// hex_dump((uintptr_t)if_.esp, if_.esp, (PHYS_BASE) - if_.esp, true); </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  palloc_free_page(cmd);</span><br><span class="line">  </span><br><span class="line">  cur-&gt;parent-&gt;create_success = <span class="literal">true</span>;</span><br><span class="line">  sema_up(&amp;cur-&gt;parent-&gt;sema_create);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;movl %0, %%esp; jmp intr_exit&quot;</span> : : <span class="string">&quot;g&quot;</span> (&amp;if_) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  NOT_REACHED ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_exec</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *cmd = *(<span class="type">char</span> **)(f-&gt;esp + <span class="number">4</span>);</span><br><span class="line">  f-&gt;eax = process_execute(cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_wait</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid = *(<span class="type">int</span> *)(f-&gt;esp + <span class="number">4</span>);</span><br><span class="line">  f-&gt;eax = process_wait(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有实现 <code>syscall_write</code> 向 <code>stdout</code> 输出的功能, 此时 <code>make test</code> 依然会全部失败</p>
<h1>Part III: 用户访存检查</h1>
<p>因为按理来说 <code>kernel</code> 不可能出现访存越界的情况<br>
所以关键点在于处理用户调用 <code>syscall</code> 时访问内存的错误</p>
<p>此处使用文档中的第一种做法</p>
<ol>
<li>为用户态内存出错设置错误码</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kill</span> <span class="params">(<span class="keyword">struct</span> intr_frame *f)</span> </span><br><span class="line">&#123;</span><br><span class="line">   thread_current()-&gt;exit_code = <span class="number">-1</span>;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现检查指针的函数 <br>
注意字符串, 要先检查字符串指针的有效性, 再逐步检查每个字符的有效性</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  thread_current()-&gt;exit_code = <span class="number">-1</span>;</span><br><span class="line">  thread_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">check_ptr</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">int</span> byte)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果不在用户内存中就报错</span></span><br><span class="line">  <span class="keyword">if</span> (!is_user_vaddr(ptr)) error_exit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次检查每个字节是否在页表中</span></span><br><span class="line">  <span class="type">int</span> pd = thread_current()-&gt;pagedir;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; byte; i++)</span><br><span class="line">    <span class="keyword">if</span> (pagedir_get_page(pd, ptr + i) == <span class="literal">NULL</span>) error_exit();</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_str</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 不能直接使用 strlen</span></span><br><span class="line">  <span class="type">char</span> *tmp = ptr;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp = check_ptr(tmp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*tmp) == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重写之前的系统调用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_exit</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> exit_code = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  thread_current()-&gt;exit_code = exit_code;</span><br><span class="line">  thread_exit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_exec</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *cmd = *(<span class="type">char</span> **)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  check_str(cmd);</span><br><span class="line">  f-&gt;eax = process_execute(cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_wait</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  f-&gt;eax = process_wait(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Part IV: 文件操作</h1>
<p>阅读 <code>file.c</code> 和 <code>filesys.c</code></p>
<p>因为这些文件操作都只能操作进程打开的文件, 所以每个进程需要记录它打开的文件, 并给这些文件一个唯一的编号从而方便后续访问<br>
编号从 2 开始, 因为 <code>stdin</code> 占有 0, <code>stdout</code> 占有 1</p>
<p>类似文件描述符, 再定义一个影子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> fd;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exec_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">file_list</span>;</span></span><br><span class="line">    <span class="type">int</span> next_fd;      <span class="comment">// 进程的文件编号分配, 注意初始化为 2</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意文件锁的问题, 文件需要互斥访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">filesys_lock</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start_process</span> <span class="params">(<span class="type">void</span> *file_name_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  lock_acquire(&amp;filesys_lock);</span><br><span class="line">  success = load (file_name, &amp;if_.eip, &amp;if_.esp);</span><br><span class="line">  lock_release(&amp;filesys_lock);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现辅助函数 <code>foreach_file</code> 用来找到目标文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="keyword">struct</span> file_shadow *<span class="title function_">foreach_file</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>* <span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list</span> * <span class="title">l</span> =</span> &amp;cur-&gt;file_list;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin(l); e != list_end(l); e = list_next(e))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span>* <span class="title">tmp</span> =</span> list_entry(e, <span class="keyword">struct</span> file_shadow, elem);</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;fd == fd) <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现这么多的系统调用, <code>f-&gt;eax</code> 是返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_create</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *file_name = *(<span class="type">char</span> **)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  check_str(file_name);</span><br><span class="line">  <span class="type">int</span> file_size = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  lock_acquire(&amp;filesys_lock);</span><br><span class="line">  f-&gt;eax = filesys_create(file_name, file_size);</span><br><span class="line">  lock_release(&amp;filesys_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_remove</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">char</span> *file_name = *(<span class="type">char</span> **)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  check_str(file_name);</span><br><span class="line"></span><br><span class="line">  lock_acquire(&amp;filesys_lock);</span><br><span class="line">  f-&gt;eax = filesys_remove(file_name);</span><br><span class="line">  lock_release(&amp;filesys_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_open</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *file_name = *(<span class="type">char</span> **)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  check_str(file_name);</span><br><span class="line"></span><br><span class="line">  lock_acquire(&amp;filesys_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">open_file</span> =</span> filesys_open(file_name);</span><br><span class="line">  lock_release(&amp;filesys_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (open_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span> *<span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> file_shadow)); </span><br><span class="line">  <span class="comment">// 打开文件, 记录文件编号, 插入打开文件的队列</span></span><br><span class="line">  tmp-&gt;f = open_file, tmp-&gt;fd = cur-&gt;next_fd++;</span><br><span class="line">  list_push_back(&amp;cur-&gt;file_list, &amp;tmp-&gt;elem);</span><br><span class="line">  f-&gt;eax = tmp-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_filesize</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span>* <span class="title">tmp</span> =</span> foreach_file(fd);</span><br><span class="line">  <span class="keyword">if</span> (tmp-&gt;f == <span class="literal">NULL</span>) f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    lock_acquire(&amp;filesys_lock);</span><br><span class="line">    f-&gt;eax = file_length(tmp-&gt;f);</span><br><span class="line">    lock_release(&amp;filesys_lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_read</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="type">char</span> *buf = *(<span class="type">char</span> **)check_ptr(f-&gt;esp + <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">  check_str(buf);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> size = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">12</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">1</span>) error_exit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文档中有写 input_getc 处理标准输入</span></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      *buf = input_getc(), buf++;</span><br><span class="line">    f-&gt;eax = size;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> file_shadow* tmp = foreach_file(fd);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      lock_acquire(&amp;filesys_lock);</span><br><span class="line">      f-&gt;eax = file_read(tmp-&gt;f, buf, size);</span><br><span class="line">      lock_release(&amp;filesys_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_write</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="type">char</span> *buf = *(<span class="type">char</span> **)check_ptr(f-&gt;esp + <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">  check_str(buf);</span><br><span class="line">  <span class="type">int</span> size = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">12</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">0</span>) error_exit();</span><br><span class="line">  <span class="comment">// 文档中写 putbuf 处理输出</span></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    putbuf(buf, size);</span><br><span class="line">    f-&gt;eax = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> file_shadow* tmp = foreach_file(fd);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">      lock_acquire(&amp;filesys_lock);</span><br><span class="line">      f-&gt;eax = file_write(tmp-&gt;f, buf, size);</span><br><span class="line">      lock_release(&amp;filesys_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_seek</span><span class="params">(<span class="keyword">struct</span> intr_frame * f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="type">int</span> pos = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span>* <span class="title">tmp</span> =</span> foreach_file(fd);</span><br><span class="line">  <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    lock_acquire(&amp;filesys_lock);</span><br><span class="line">    file_seek(tmp-&gt;f, pos);</span><br><span class="line">    lock_release(&amp;filesys_lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_tell</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span>* <span class="title">tmp</span> =</span> foreach_file(fd);</span><br><span class="line">  <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    lock_acquire(&amp;filesys_lock);</span><br><span class="line">    f-&gt;eax = file_tell(tmp-&gt;f);</span><br><span class="line">    lock_release(&amp;filesys_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_close</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = *(<span class="type">int</span> *)check_ptr(f-&gt;esp + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span>* <span class="title">tmp</span> =</span> foreach_file(fd);</span><br><span class="line">  <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    lock_acquire(&amp;filesys_lock);</span><br><span class="line">    file_close(tmp-&gt;f);</span><br><span class="line">    <span class="comment">// 从队列中移除, 释放 file_shadow</span></span><br><span class="line">    list_remove(&amp;tmp-&gt;elem);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    lock_release(&amp;filesys_lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后当进程结束的时候, 要释放所有文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">process_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (!list_empty(&amp;cur-&gt;file_list))</span><br><span class="line">  &#123;</span><br><span class="line">    e = list_pop_front(&amp;cur-&gt;file_list);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_shadow</span>* <span class="title">tmp</span> =</span> list_entry(e, <span class="keyword">struct</span> file_shadow, elem);</span><br><span class="line">    lock_acquire(&amp;filesys_lock);</span><br><span class="line">    file_close(tmp-&gt;f);</span><br><span class="line">    lock_release(&amp;filesys_lock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: exit(%d)\n&quot;</span>, cur-&gt;name, cur-&gt;to-&gt;exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Part V: 拒绝写入可执行文件</h1>
<p>在程序运行的时候, 其他进程不能修改程序, 很合理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">exec_file</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start_process</span> <span class="params">(<span class="type">void</span> *file_name_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 把参数信息放到栈中</span></span><br><span class="line">  push_argument(&amp;if_.esp, cmd);</span><br><span class="line">  <span class="comment">// hex_dump((uintptr_t)if_.esp, if_.esp, (PHYS_BASE) - if_.esp, true); </span></span><br><span class="line"></span><br><span class="line">  lock_acquire(&amp;filesys_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> filesys_open(file_name);</span><br><span class="line">  file_deny_write(f);</span><br><span class="line">  lock_release(&amp;filesys_lock);</span><br><span class="line">  thread_current()-&gt;exec_file = f;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">process_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  lock_acquire(&amp;filesys_lock);</span><br><span class="line">  file_close(cur-&gt;exec_file);</span><br><span class="line">  lock_release(&amp;filesys_lock);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: exit(%d)\n&quot;</span>, cur-&gt;name, cur-&gt;to-&gt;exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此, 80 个测试点 <code>All Pass</code></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/09/25/1pintos/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-09-29 15:40:00
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Labs/" title="Labs">
                        <b>#</b> Labs
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Lab/" title="Lab">
                        #Lab
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/C/" title="C">
                        #C
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/OS/" title="OS">
                        #OS
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/10/02/golang/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">预先准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Part I: 参数分离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Part II: 系统调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Part III: 用户访存检查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Part IV: 文件操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Part V: 拒绝写入可执行文件</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Pintos%20Project%202 + '&url=' + http%3A%2F%2Fexample.com%2F2023%2F09%2F29%2F2pintos%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2023/09/29/2pintos/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
