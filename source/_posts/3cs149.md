---
title: StanFord CS149 Assignment3 简记
date: 2024-02-12 14:20:10
mathjax: true
categories:
- Labs
tags: 
- C++
- Lab
- Parallel
- CUDA
---

[`Github`](https://github.com/lzlcs/Courses)
# Part 1

实现简单, 见代码

## 问题 1

**CUDA**
```cpp
Running 3 timing tests:
Effective BW by CUDA saxpy:  125.259 ms         [8.922 GB/s]
saxpy without data transfer: 6.136 ms
Effective BW by CUDA saxpy:  126.499 ms         [8.835 GB/s]
saxpy without data transfer: 6.198 ms
Effective BW by CUDA saxpy:  119.858 ms         [9.324 GB/s]
saxpy without data transfer: 6.047 ms
```
**CPU**
```cpp
[saxpy ispc]:           [8.482] ms      [35.134] GB/s   [4.716] GFLOPS
[saxpy task ispc]:      [8.202] ms      [36.335] GB/s   [4.877] GFLOPS
```

可见 `saxpy` 的 `CUDA` 版本显著慢于 `CPU(ispc)` 版本

## 问题 2

可见计算的部分非常迅速, 瓶颈是数据传输

# Part 2

## 任务 1

首先要确定 线程块的数量和每个线程块中的线程数量

1. 常规设定线程数量为 256
2. 计算所需线程数量 
    - 超过 256, `<<<threads_num / 256, 256>>>`(此处必然可以整除)
    - 不超过 256 `<<<1, threads_num>>>`

之后就按照 `README` 文件上的代码翻译即可, 剩余见代码

## 任务 2

首先 `output[idx] = (input[idx] == input[idx + 1])` 再求前缀和
- 此时 `output` 数组的和就是要返回的值

由于 `explicit` 的特性
- `output[idx] + 1 == output[idx + 1]` 的位置就是要找的下标之一
-  `output[idx]` 的值还是答案数组的下标

所以更新答案 `result[output[idx]] = idx`




